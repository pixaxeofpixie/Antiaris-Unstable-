using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;
using Terraria;
using Terraria.GameContent.Generation;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;
using Terraria.World.Generation;

namespace Antiaris
{ 
    public class AntiarisWorld : ModWorld
    {
        public bool savedAdventurer = false;
        public bool DownedAntlionQueen = false;
        public bool DownedTowerKeeper = false;
        public bool DownedBarrier = false;
        public bool FinishedPirateQuest = false;
        public bool FinishedGuideQuest = false;
        public bool DownedDeadlyJones = false;
        public int StartPositionX = 0;
        public int StartPositionY = 0;
        public ushort ChestType = (ushort)ModLoader.GetMod("Antiaris").TileType("Cabinet");
        public int Bed = 0;
        public int Table = 0;
        public int Wood = TileID.WoodBlock;
        public int WoodWall = 4;
        public int StoneWall = 5;
        public int Brick = 38;
        public int WoodTile = 106;
        public int Door = 0;
        public int Platform = 0;
        public int Stone = TileID.Stone;
        public int LivingWoodWall = 78;
        public int PlankedWall = 27;
        public int StoneSlab = 273;
        public int StoneSlabWall = 147;
        public int Fence = 106;
        public int Grass = 2;
        public int Chair = 0;
        public int CoveBlock1 = 0;
        public int CoveBlock2 = 1;
        public ushort Mailbox = (ushort)ModLoader.GetMod("Antiaris").TileType("Mailbox");
        public ushort Dray = (ushort)ModLoader.GetMod("Antiaris").TileType("LeafDray");
        private bool GenerateHouse;
        private bool GenerateBoat;
        private bool GenerateTorment;
        private bool GenerateStone;
        private bool GeneratePyramid;
        private bool GenerateCrystal;
        private bool GenerateSubmarine;
        private bool GenerateFinder;
        private bool GenerateMirrorTower;
        private bool GenerateSnowHouse;
        private bool GenerateHiveShrine;
        public bool GeneratePirateCove;
        public bool frozenTime;

        //0=air, 1=snow, 2=boreal wood, 3=wooden beam, 4=glass, 5=boreal wood platform, 6=cobweb
        static readonly byte[,] SnowHouseTiles =
        {
			{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
			{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
			{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
			{1,1,1,1,1,1,7,5,5,5,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,1,1,1,1,1,1},
			{7,1,1,1,1,1,7,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,7,7},
			{7,7,1,1,7,7,7,7,7,1,1,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,2,1,1,1,7,7,7},
			{7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,4,1,1,7,7,7,7},
			{7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,5,5,7,7,7,7,7,7,4,7,7,7,7,7,7},
			{7,7,7,7,7,7,7,7,7,7,7,2,7,7,7,7,7,7,7,7,7,7,7,7,7,7,2,7,7,7,7,7,7},
			{7,7,7,7,7,7,7,2,5,5,5,2,2,7,5,5,5,5,7,7,7,7,7,7,7,2,2,2,7,7,7,7,7},
			{0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0},
			{0,0,0,0,0,0,1,1,2,2,2,2,0,0,6,6,6,0,0,0,0,0,0,2,2,2,2,1,1,0,0,0,0},
			{0,0,0,0,0,0,1,1,1,1,2,2,2,2,0,6,0,0,0,0,0,2,2,2,2,1,1,1,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,0,0,0,2,2,2,2,1,1,1,1,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
		};

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        static readonly byte[,] SnowHouseSlopes =
        {
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{5,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5},
			{0,2,0,0,0,5,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
			{0,0,5,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,4,0,0,0,0,3,0,5,5,5,5,0,0,0,0,0,0,0,4,0,3,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,5,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,5,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,3,0,0,0,4,0,0,0,0,0,0,1,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0}
		};

        //0=none, 1=boreal wood wall, 2=wood wall, 3=living wood wall, 4=boreal wood fence, 5=glass wall
        static readonly byte[,] SnowHouseWalls = 
		{
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,1,3,1,1,1,1,1,1,1,1,1,1,3,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,1,3,1,5,0,1,1,1,1,1,1,1,3,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,1,3,1,0,5,1,1,1,1,1,1,1,3,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,1,3,1,1,1,1,1,1,1,1,1,1,3,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		};


        //0=air, 1=dirt/snow/ice, 2=wood, 3=stone brick, 4=stone, 5=platform, 6=stone slab, 7=grass		
        static readonly byte[,] GuideHouse =
        {
			{1,1,4,4,4,1,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1},
			{1,1,4,4,1,1,3,6,6,6,6,6,6,6,3,4,4,4,1,1,4,4,1,1},
            {1,1,1,1,1,1,3,6,0,0,0,0,0,6,3,1,4,4,1,4,4,1,1,4},
            {1,1,1,1,1,4,3,6,0,0,0,0,0,6,3,1,1,1,4,4,1,1,4,4},
            {7,7,7,3,3,3,3,6,0,0,6,6,6,6,3,3,3,3,3,3,3,1,1,4},
            {0,0,0,2,2,2,2,1,0,0,2,2,2,2,2,2,1,1,1,2,2,7,7,7},
            {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8},
            {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8},
            {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8},
            {8,8,8,8,8,8,8,5,5,5,5,8,8,8,8,8,8,8,8,2,8,8,8,8},
            {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,2,8,8,8,8},
            {8,8,8,8,2,2,8,8,8,8,8,8,8,8,8,8,8,8,2,2,8,8,8,8},
            {0,0,0,0,2,2,2,5,5,5,5,2,2,2,2,2,2,2,2,2,3,3,0,0},
			{0,0,0,0,3,2,2,0,0,0,0,0,0,0,0,0,0,2,2,3,3,3,0,0},
			{0,0,0,0,3,3,2,2,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0},
			{0,0,0,0,0,3,3,2,2,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0},
			{0,0,0,0,0,3,3,3,2,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,3,3,3,2,2,0,0,2,2,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,3,3,3,2,2,2,2,3,3,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,3,3,3,2,2,3,3,3,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0}
		};

        //0=air, 1=stone wall, 2=wooden wall, 3=living wood wall, 4=planked wall, 5=stone slab wall, 6=fence
        static readonly byte[,] GuideHouseWall =
        {
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0},
			{6,6,6,6,6,0,0,2,5,5,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{6,0,6,6,6,2,3,2,2,2,2,0,0,0,0,0,2,3,2,6,6,6,6,6},
			{0,0,6,0,6,0,0,2,2,2,2,0,0,0,2,2,2,3,2,6,0,6,6,0},
			{0,0,6,0,0,0,0,0,2,2,2,2,0,0,2,2,2,3,2,0,0,0,6,0},
			{0,0,0,0,0,0,0,0,2,2,2,2,3,2,2,2,2,3,2,0,0,0,0,0},
			{0,0,0,0,0,0,3,2,2,2,2,2,3,2,2,2,2,3,2,0,0,0,0,0},
			{0,0,0,0,0,2,3,2,2,2,2,2,3,2,2,2,2,3,2,0,0,0,0,0},
			{0,0,0,0,0,0,4,3,4,4,3,4,4,3,4,4,3,4,0,0,0,0,0,0},
			{0,0,0,0,0,0,4,3,4,4,3,4,4,3,4,4,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,3,4,4,3,4,4,3,4,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,3,4,4,3,4,4,3,4,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,4,4,4,3,4,4,3,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,4,4,3,4,4,3,4,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,4,3,4,4,3,4,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		};

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        static readonly byte[,] GuideHouseSlopes =
        {
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,2,0,0,0,3,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1,0,0},
			{0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,0,4,0,0,0,1,0,0,0},
			{0,0,0,0,2,0,0,0,3,0,0,0,0,0,0,4,0,0,0,1,0,0,0,0},
			{0,0,0,0,0,2,0,0,0,3,0,0,0,0,4,0,0,0,1,0,0,0,0,0},
			{0,0,0,0,0,0,2,0,0,0,3,0,0,4,0,0,0,1,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,2,0,0,0,3,4,0,0,0,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0}
		};

        //0=air, 1=wood, 2=wooden bean
        private static readonly byte[,] BoatTiles =
        {
            {0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
            {0,0,1,1,0,0,0,2,0,0,0,2,0,0,1,1,1,0,0,0,0,0},
            {0,1,1,0,0,0,0,2,0,0,0,2,0,0,0,0,1,1,1,0,0,0},
            {1,1,1,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,1,1,0,0},
            {0,1,1,1,1,1,1,1,0,0,0,2,0,0,0,0,0,0,0,1,1,1},
            {0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,1,1,1,1,1,1,1,1,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,1,1,1,1,1,1,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=air, 1=wall, 2=fence, 3=sail
        private static readonly byte[,] BoatWalls =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
            {0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
            {0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
            {0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,2,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0},
            {0,0,0,0,0,0,0,3,3,3,0,0,0,2,0,0,0,0,2,0,0,0},
            {0,0,0,0,0,0,0,3,3,3,0,0,0,2,0,0,0,0,2,0,0,0},
            {0,0,0,0,0,0,3,3,3,3,3,0,0,2,0,0,0,0,2,0,0,0},
            {0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        private static readonly byte[,] BoatSlopes =
        {
            {0,0,0,4,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0},
            {0,0,4,1,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,0,0},
            {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0},
            {4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,0,0},
            {0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
            {0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,5,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=active(fals)
        private static readonly byte[,] BoatNoneActive =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=oil rag sconse, 2=trapdoor, 3=alchemy lantern, 4=platform, 5=wooden crate, 6=bookcase, 7=keg, 8=bottle, 9=barrel, 10=dead mans chest
        private static readonly byte[,] BoatObjects =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,3,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0},
            {0,0,0,0,0,0,4,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,9,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,4,4,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=air, 1=none, 2=sandstone, 3=sand, 4=cloud, 5=ore
        private static readonly byte[,] PyramidTiles =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,4,4,4,4,4,4,4,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,4,4,4,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,3,3,3,3,3,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0},
            {1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,1},
            {1,1,1,1,1,4,4,4,4,4,4,4,4,4,3,3,3,3,3,5,5,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1},
            {1,1,1,1,1,4,4,4,4,4,4,4,4,3,3,3,3,5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1},
            {1,1,1,1,4,4,4,4,4,4,3,3,3,3,3,3,3,5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,1,1,1},
            {1,1,1,4,4,4,4,4,4,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,1,1},
            {1,1,1,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5,3,3,3,4,4,4,4,4,4,4,4,4,1},
            {1,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,3,3,3,3,4,4,4,4,4,4,1},
            {1,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,3,3,3,3,3,3,3,4,4,4,4,4,4,4},
            {4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4},
            {4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4},
            {1,1,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4},
            {0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0},
            {0,0,0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,2,1,1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,2,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        private static readonly byte[,] PyramidSlopes =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,0,4,3,4,3,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=air, 1=sandstone, 2=cloud
        private static readonly byte[,] PyramidWalls =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0},
            {0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0},
            {0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0},
            {0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0},
            {0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0},
            {0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0},
            {0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0},
            {0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0},
            {0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };


        //0=air, 1=tin/copper, 2=sand, 3=platform, 4=gemspark, 5=water sensor, 6=lava sensor, 7=honey sensor
        static readonly byte[,] SubmarineTiles =
        {
            {0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,0,0,0,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,0,0,0,0,1,2,2,2,2,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,1,1,1,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,0,0,2,1,0,0,0,0,1,0,0,0,4,4,4,0,0,0,1,1,0,0},
            {0,0,0,0,0,2,1,0,3,3,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0},
            {0,0,0,0,2,2,1,0,3,3,0,1,0,0,0,0,0,0,0,5,6,7,0,1,4},
            {0,0,0,2,2,2,1,0,3,3,0,1,0,0,0,0,0,0,0,3,3,3,0,1,4},
            {0,0,2,2,2,2,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4},
            {0,2,2,2,2,2,2,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2},
            {2,2,2,2,2,2,2,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,2,2},
            {2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2}
        };

        //0=air, 1=tin/copper, 2=stone, 3=glass
        static readonly byte[,] SubmarineWalls =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
            {0,0,0,0,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,1,1,1,1,2,2,2,2,1,1,1,1,1,3,3,3,1,1,1,1,0,0},
            {0,0,0,1,1,1,1,2,2,2,2,1,1,1,1,1,3,3,3,1,1,1,1,0,0},
            {0,0,0,0,1,1,1,2,2,2,2,1,1,1,1,1,3,3,3,1,1,1,1,0,0},
            {0,0,0,0,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        static readonly byte[,] SubmarineSlopes =
        {
            {0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
            {0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,4,0,3,0,0,0,4,1,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
            {0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
            {0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,5},
            {2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1,0,0,2,3,2,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0}
        };

        //0=air, 1=compressor, 2=chest, 3=door, 4=trapdoor
        static readonly byte[,] SubmarineObjects =
        {
            {0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };


        //0=air, 1=dirt, 2=stone brick, 3=demonite brick, 4=platform
        static readonly byte[,] TowerTiles =
        {
            {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
			{1,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
			{4,2,2,3,3,3,3,3,3,3,3,3,2,2,4},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,2,2,0,0,0,0,0,0,0,0,0,2,2,0},
			{0,2,2,0,0,0,0,0,0,0,0,0,2,2,0},
			{0,2,2,2,0,0,0,0,0,0,0,2,2,2,0},
			{0,2,2,2,3,3,3,3,4,4,3,2,2,2,0},
			{0,0,0,2,3,0,0,0,0,0,3,2,0,0,0},
			{0,0,0,2,3,0,0,0,0,0,3,2,0,0,0},
			{0,0,0,2,3,0,0,0,0,0,3,2,0,0,0},
			{0,0,2,2,3,3,3,3,4,4,3,2,2,0,0},
			{0,0,2,2,3,0,0,0,0,0,3,2,2,0,0},
			{0,0,0,2,3,0,0,0,0,0,3,2,0,0,0},
			{0,0,0,2,3,0,0,0,0,0,3,2,0,0,0},
			{0,0,2,2,3,3,3,3,4,4,3,2,2,0,0},
			{0,2,2,2,0,0,0,0,0,0,0,2,2,2,0},
			{2,2,2,0,0,0,0,0,0,0,0,0,2,2,2},
			{2,2,2,0,0,0,0,0,0,0,0,0,2,2,2},
			{0,2,2,0,0,0,0,0,0,0,0,0,2,2,0},
			{0,2,2,0,0,0,0,0,0,0,0,0,2,2,0},
			{0,2,2,2,0,0,0,0,0,0,0,2,2,2,0},
			{2,2,2,2,2,2,4,4,4,2,2,2,2,2,2},
			{2,2,0,0,0,0,0,0,0,0,0,0,0,2,2},
			{2,2,0,0,0,0,0,0,0,0,0,0,0,2,2},
			{2,2,0,0,0,0,0,0,0,0,0,0,0,2,2}
        };

        //0=air, 1=stone brick, 2=demonite brick
        static readonly byte[,] TowerWalls =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
			{0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
			{0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
			{0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
			{0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
			{0,0,1,1,2,1,1,2,1,1,2,1,1,0,0},
            {0,0,0,1,2,1,1,2,1,1,2,1,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
            {0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
            {0,0,0,0,2,1,1,2,1,1,2,0,0,0,0},
			{0,0,0,1,2,1,1,1,1,1,2,1,0,0,0},
            {0,0,0,1,2,1,1,1,1,1,2,1,0,0,0},
			{0,0,0,1,2,1,1,1,1,1,2,1,0,0,0},
			{0,0,0,2,2,2,2,2,2,2,2,2,0,0,0},
			{0,0,0,1,2,1,1,1,1,1,2,1,0,0,0},
            {0,0,0,1,2,1,1,1,1,1,2,1,0,0,0},
			{0,0,1,1,1,1,1,1,1,1,1,1,1,0,0},
			{0,0,0,0,1,0,0,1,0,0,1,0,0,0,0},
            {0,0,0,0,1,0,0,1,0,0,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        static readonly byte[,] TowerSlopes =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{2,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,5,2,0,0,0,0,0,0,0,0,0,1,5,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,2,0,0,0,0,0,0,0,0,0,1,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,4,0,0,0,0,0,0,0,0,0,3,0,0},
			{0,4,0,0,0,0,0,0,0,0,0,0,0,3,0},
			{4,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
			{1,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,3,0,0,0,0,0,0,0,4,0,0,0},
			{4,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0,0,0,0,2,0},
        };

        //0=old block, 1=dirt, 2=stone, 3=wood, 4=wood platforms, 5=rope, 6=cobweb, 7=air, 8=water, 9=gold coins
        private static readonly byte[,] PirateCoveTiles =
        {
            {0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,2,2,2,2,8,8,8,8,8,8,1,1,1,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,2,2,2,8,8,8,8,8,8,8,8,1,1,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,2,2,2,2,8,8,8,8,8,8,8,8,8,1,1,1,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,2,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1,0,0,0,0,0,0,0},
            {0,0,0,0,0,1,1,1,1,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,0,0,0,0},
            {0,0,0,0,1,1,1,1,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,1,1,1,0},
            {0,0,0,0,1,0,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,1,1,1,0},
            {0,0,1,1,1,1,1,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,8,2,2,2,1,1},
            {0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,8,8,8,8,1,1},
            {0,1,1,1,1,7,7,7,7,7,7,7,7,7,5,5,9,7,7,7,7,7,7,1,8,8,8,8,1,1},
            {0,2,1,3,7,7,7,7,7,7,7,7,7,7,5,5,7,7,7,7,7,7,7,7,7,7,7,2,2,2},
            {2,2,1,3,7,7,7,7,7,7,7,7,7,7,5,5,7,7,7,7,7,7,7,7,7,7,7,2,2,2},
            {2,2,7,7,7,7,7,7,7,7,7,7,7,7,5,5,7,7,7,7,7,7,7,7,7,7,1,1,2,2},
            {2,2,7,7,7,7,7,7,7,7,7,7,7,7,5,5,7,7,7,7,7,7,7,7,7,7,1,1,2,0},
            {2,2,7,7,7,7,7,7,7,7,7,7,7,7,5,5,5,7,7,7,7,7,7,7,7,7,1,1,2,0},
            {2,2,2,3,7,7,7,7,7,7,7,7,7,7,5,5,5,7,7,7,7,7,7,7,7,7,7,1,1,0},
            {2,2,8,3,7,7,7,7,7,7,7,7,7,5,5,5,5,7,7,7,7,7,7,7,7,7,7,1,1,0},
            {2,2,2,7,7,7,7,7,7,7,7,7,7,5,5,5,5,7,7,7,7,7,7,7,7,7,2,1,1,0},
            {2,2,2,6,6,7,7,7,7,7,7,7,7,5,5,5,5,7,7,7,7,7,7,7,7,7,2,1,1,0},
            {2,1,6,6,6,7,7,7,7,7,7,7,7,5,5,5,7,7,7,7,7,7,7,7,7,2,2,1,1,0},
            {1,1,3,3,3,7,7,7,7,3,3,6,7,3,3,3,3,7,7,7,7,7,7,7,7,2,1,1,0,0},
            {1,1,7,9,9,7,7,7,7,9,6,6,6,1,1,1,1,7,7,7,7,7,1,1,1,1,1,1,0,0},
            {1,1,1,1,1,1,7,7,6,7,7,6,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,1,1,1,1,1,1,6,6,1,1,2,2,2,2,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0},
            {0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=none, 1=wood, 2=grass, 3=old
        private static readonly byte[,] PirateCoveWalls =
        {
            {3,3,3,3,3,3,3,3,3,3,3,1,3,1,1,3,3,1,1,3,3,3,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,3,3,3,3,0,1,0,1,1,0,0,1,1,0,3,3,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,0,0,1,1,0,0,3,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,3,3},
            {3,3,3,3,3,0,0,0,0,0,0,0,0,1,1,2,2,0,1,1,1,1,0,0,0,0,0,0,0,3},
            {3,3,3,3,2,2,1,2,0,0,2,2,1,1,1,1,2,2,2,1,1,0,0,0,0,0,0,0,0,3},
            {3,3,0,1,1,1,1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
            {3,3,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
            {3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
            {3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
            {3,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
            {3,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
            {3,0,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
            {3,0,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
            {3,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,3},
            {3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,2,2,3,3,3},
            {3,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,2,2,2,2,2,2,2,3,3,3},
            {3,0,2,2,1,1,2,2,1,1,1,2,2,0,0,0,1,1,0,0,2,2,2,2,2,2,3,3,3,3},
            {3,0,2,2,2,0,0,2,2,0,1,2,2,2,0,0,1,1,2,2,2,2,2,2,2,0,3,3,3,3},
            {3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3},
            {3,3,3,3,3,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
            {3,3,3,3,3,3,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        private static readonly byte[,] PirateCoveSlopes =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0},
            {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0},
            {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,3,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
        };

        //0=old block, 1=hive block, 2=honey block,3=none,4=honey,5=honey platform
        public static readonly byte[,] HiveShrineTiles =
        {
            {0,0,0,0,0,0,0,0,0,0,2,0,0,0},
            {0,0,0,0,1,1,1,1,1,1,2,0,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,1,1,1,1,1,4,4,2,2,1,1,1,1},
            {0,1,1,1,4,4,4,4,4,2,2,1,1,1},
            {1,1,1,4,4,4,4,4,4,4,4,4,1,1},
            {1,1,1,3,3,3,3,3,3,3,3,3,1,1},
            {1,1,1,3,3,3,5,5,3,3,3,3,1,1},
            {1,1,3,3,3,3,3,3,3,3,3,3,1,1},
            {1,1,3,3,3,3,3,3,3,3,3,3,1,1},
            {1,1,3,3,3,3,3,3,3,3,3,2,1,1},
            {2,1,3,3,3,3,2,3,3,3,3,2,1,1},
            {2,1,1,1,3,3,2,3,3,3,1,1,1,1},
            {2,2,1,1,1,1,2,2,1,1,1,1,1,0},
            {0,0,2,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,0,0,1,1,1,1,1,1,0,0,0,0},
        };

        //1=hive wall
        public static readonly byte[,] HiveShrineWalls =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,1,1,1,1,1,1,0,0,0,0},
            {0,0,0,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,1,0,0},
            {0,0,1,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,1,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        };

        //0=none, 1=bottom-left, 2=bottom-right, 3=top-left, 4=top-right, 5=half
        public static readonly byte[,] HiveShrineSlopes =
        {
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,1,0,0,0,0,0,0,0,0},
            {0,0,0,1,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,5,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,3,0,0,0,0,0,0,4,0,0,0},
            {0,0,0,0,0,3,0,3,4,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        };

        internal static readonly int[] SnowHouseGenTiles =
        {
            147,
            161,
            163,
            200
        };

        internal static readonly int[] HiveShrineGenTiles =
        {
            59,
            60
        };

        public static int BoatPositionX = 0;
        public static int BoatPositionY = 0;
        private int CheckTile = TileID.Dirt;
        private int HellLayer = Main.maxTilesY - 200;
        private int PyramidPositionX = 0;
        private int PyramidPositionY = 0;
        private int Size = WorldGen.genRand.Next(6, 10);
        private int SnowHousePositionX = 0;
        private int SnowHousePositionY = 0;
        private int TowerPositionX = 0;
        private int TowerPositionY = 0;
        public static int PirateCovePositionX = 0;
        public static int PirateCovePositionY = 0;
        public static int HiveShrinePositionX = 0;
        public static int HiveShrinePositionY = 0;
        public static int heavenClock = 0;
        public static int heavenTimer = 0;

        public override void Initialize()
        {
            GenerateHouse = false;
            GenerateBoat = false;
            GenerateTorment = false;
            GenerateStone = false;
            GeneratePyramid = false;
            savedAdventurer = false;
            GenerateCrystal = false;
            GenerateSubmarine = false;
            GenerateFinder = false;
			GenerateMirrorTower = false;
			GenerateSnowHouse = false;
            GeneratePirateCove = false;
            GenerateHiveShrine = false;
			DownedAntlionQueen = false;
			DownedTowerKeeper = false;
			DownedBarrier = false;
            DownedDeadlyJones = false;
            FinishedGuideQuest = false;
            FinishedPirateQuest = false;
            heavenClock = 0;
            heavenTimer = 0;
        }

        public override TagCompound Save()
        {
            var Generated = new BitsByte();
            Generated[0] = GenerateHouse;
            Generated[1] = GenerateBoat;
            Generated[2] = GenerateTorment;
            Generated[3] = GenerateStone;
            Generated[4] = GeneratePyramid;
            Generated[5] = savedAdventurer;
            Generated[6] = GenerateCrystal;
            Generated[7] = GenerateSubmarine;
			var Generated2 = new BitsByte();
			Generated2[0] = GenerateFinder;
			Generated2[1] = GenerateMirrorTower;
			Generated2[2] = GenerateSnowHouse;
			Generated2[3] = GeneratePirateCove;
            Generated2[4] = GenerateHiveShrine;
			var Downed = new List<string>();
            if (DownedAntlionQueen) Downed.Add("antlionQueen");
			if (DownedTowerKeeper) Downed.Add("towerKeeper");
            if (DownedDeadlyJones) Downed.Add("deadlyJones");
            var Finished = new List<string>();
            if (FinishedPirateQuest) Finished.Add("pirateQuest");
            if (FinishedGuideQuest) Finished.Add("guideQuest");
            return new TagCompound
            {
                {
                    "StartPositionX",
                    (object)StartPositionX
                },
                {
                    "StartPositionY",
                    (object)StartPositionY
                },
                {
                    "Generated",
                    (byte)Generated
                },
				{
					"Generated2",
					(byte)Generated2
				},
                {
                    "Version", 0
                },
				{
                    "Finished", Finished
                },
                {
                    "Downed", Downed
                },
                {
                    "PirateCovePositionX",
                    (object)PirateCovePositionX
                },
                {
                    "PirateCovePositionY",
                    (object)PirateCovePositionY
                },
                {
                    "HiveShrinePositionX",
                    (object)HiveShrinePositionY
                },
                {
                    "HiveShrinePositionY",
                    (object)HiveShrinePositionX
                },
                {
                    "BoatPositionX",
                    (object)BoatPositionX
                },
                {
                    "BoatPositionY",
                    (object)BoatPositionY
                },
                {
                    "heavenClock",
                    (object)heavenClock
                },
                {
                    "heavenTimer",
                    (object)heavenTimer
                },
            };
        }

        public override void Load(TagCompound tag)
        {
            var Generated = (BitsByte)tag.GetByte("Generated");
            GenerateHouse = Generated[0];
            GenerateBoat = Generated[1];
            GenerateTorment = Generated[2];
            GenerateStone = Generated[3];
            GeneratePyramid = Generated[4];
            savedAdventurer = Generated[5];
            GenerateCrystal = Generated[6];
            GenerateSubmarine = Generated[7];

			var Generated2 = (BitsByte)tag.GetByte("Generated2");
			GenerateFinder = Generated2[0];
			GenerateMirrorTower = Generated2[1];
			GenerateSnowHouse = Generated2[2];
            GeneratePirateCove = Generated2[3];
            GenerateHiveShrine = Generated2[4];
            StartPositionX = tag.GetInt("StartPositionX");
            StartPositionY = tag.GetInt("StartPositionY");
            var Downed = tag.GetList<string>("Downed");
            DownedAntlionQueen = Downed.Contains("antlionQueen");
			DownedTowerKeeper = Downed.Contains("towerKeeper");
            DownedDeadlyJones = Downed.Contains("deadlyJones");
            var Finished = tag.GetList<string>("Finished");
            FinishedPirateQuest = Finished.Contains("pirateQuest");
            FinishedGuideQuest = Finished.Contains("guideQuest");
            PirateCovePositionX = tag.GetInt("PirateCovePositionX");
            PirateCovePositionY = tag.GetInt("PirateCovePositionY");
            BoatPositionX = tag.GetInt("BoatPositionX");
            BoatPositionY = tag.GetInt("BoatPositionY");
            HiveShrinePositionX = tag.GetInt("HiveShrinePositionX");
            HiveShrinePositionX = tag.GetInt("HiveShrinePositionY");
            heavenClock = tag.GetInt("heavenClock");
            heavenTimer = tag.GetInt("heavenTimer");
        }

        public override void LoadLegacy(BinaryReader reader)
        {
            int loadVersion = reader.ReadInt32();
            if (loadVersion == 0)
            {
                BitsByte Flags2 = reader.ReadByte();
                BitsByte Flags3 = reader.ReadByte();
                DownedAntlionQueen = Flags2[0];
				DownedTowerKeeper = Flags2[1];
                DownedDeadlyJones = Flags2[2];
                FinishedPirateQuest = Flags3[0];
                FinishedGuideQuest = Flags3[1];
                StartPositionX = reader.ReadInt32();
                StartPositionY = reader.ReadInt32();
                heavenClock = reader.ReadInt32();
                heavenTimer = reader.ReadInt32();
            }
        }

        public override void NetSend(BinaryWriter writer)
        {
            BitsByte Flags1 = new BitsByte();
			BitsByte Flags12 = new BitsByte();
			BitsByte Flags2 = new BitsByte();
            BitsByte Flags3 = new BitsByte();

            Flags1[0] = GenerateHouse;
            Flags1[1] = GenerateBoat;
            Flags1[2] = GenerateTorment;
            Flags1[3] = GenerateStone;
            Flags1[4] = GeneratePyramid;
            Flags1[5] = savedAdventurer;
            Flags1[6] = GenerateCrystal;
            Flags1[7] = GenerateSubmarine;

			Flags12[0] = GenerateFinder;
			Flags12[1] = GenerateMirrorTower;
			Flags12[2] = GenerateSnowHouse;
			Flags12[3] = GeneratePirateCove;
            Flags12[4] = GenerateHiveShrine;

			Flags2[0] = DownedAntlionQueen;
			Flags2[1] = DownedTowerKeeper;
            Flags2[2] = DownedDeadlyJones;

            Flags3[0] = FinishedPirateQuest;
            Flags3[1] = FinishedGuideQuest;
            writer.Write(Flags1);
			writer.Write(Flags12);
			writer.Write(Flags2);
            writer.Write(Flags3);
            writer.Write(StartPositionX);
            writer.Write(StartPositionY);
            writer.Write(PirateCovePositionX);
            writer.Write(PirateCovePositionY);
            writer.Write(BoatPositionX);
            writer.Write(BoatPositionY);
            writer.Write(HiveShrinePositionX);
            writer.Write(HiveShrinePositionY);
            writer.Write(heavenClock);
            writer.Write(heavenTimer);
        }

        public override void NetReceive(BinaryReader reader)
        {
            BitsByte Flags1 = reader.ReadByte();
            BitsByte Flags2 = reader.ReadByte();
			BitsByte Flags12 = reader.ReadByte();
			BitsByte Flags3 = reader.ReadByte();
            GenerateHouse = Flags1[0];
            GenerateBoat = Flags1[1];
            GenerateTorment = Flags1[2];
            GenerateStone = Flags1[3];
            GeneratePyramid = Flags1[4];
            savedAdventurer = Flags1[5];
            GenerateCrystal = Flags1[6];
            GenerateSubmarine = Flags1[7];

            GenerateFinder = Flags12[0];
			GenerateMirrorTower = Flags12[1];
			GenerateSnowHouse = Flags12[2];
            GeneratePirateCove = Flags12[3];
            GenerateHiveShrine = Flags12[4];
			
			DownedAntlionQueen = Flags2[0];
			DownedTowerKeeper = Flags2[1];
            DownedDeadlyJones = Flags2[2];
            FinishedPirateQuest = Flags3[0];
            FinishedGuideQuest = Flags3[1];
            StartPositionX = reader.ReadInt32();
            StartPositionY = reader.ReadInt32();
            PirateCovePositionX = reader.ReadInt32();
            PirateCovePositionY = reader.ReadInt32();
            BoatPositionX = reader.ReadInt32();
            BoatPositionY = reader.ReadInt32();
            HiveShrinePositionX = reader.ReadInt32();
            HiveShrinePositionY = reader.ReadInt32();
            heavenClock = reader.ReadInt32();
            heavenTimer = reader.ReadInt32();
        }

        public override void PostUpdate()
        {
            for (var k = 0; k < 200; k++)
            {
                if (NPC.AnyNPCs(mod.NPCType("UnconsciousGuide")))
                {
                    if (Main.npc[k].type == NPCID.Guide && Main.npc[k].active)
                    {
                        Main.npc[k].life = -1;
                        Main.npc[k].active = false;
                        Main.npc[k].checkDead();
                    }
                }
            }         
        }

        public override void ModifyWorldGenTasks(List<GenPass> tasks, ref float totalWeight)
        {
            var index = tasks.FindIndex(x => x.Name == "Planting Trees");
            if (index != -1)
            {
                tasks.Add(new PassLegacy("[Antiaris] Chest Finder", AddChestFinder));
                tasks.Add(new PassLegacy("[Antiaris] Guide House", AddGuideHouse));
            }
            index = tasks.FindIndex(x => x.Name == "Micro Biomes");
            if (index != -1)
            {
                tasks.Add(new PassLegacy("[Antiaris] Snow House", AddSnowHouse));
                tasks.Add(new PassLegacy("[Antiaris] Submarine", AddSubmarine));
                tasks.Add(new PassLegacy("[Antiaris] Cursed Tower", AddTower));
                tasks.Add(new PassLegacy("[Antiaris] Pirate Boat", AddBoat));
				tasks.Insert(index + 1, new PassLegacy("Moai", delegate (GenerationProgress progress)
				{
					for (int k = 0; k < 2; k++)
					{
						int minX = 0;
						int maxX = 0;
						int startX = 500;
						int endX = 50;
						switch (k)
						{
							case 0:
								minX = Main.maxTilesX - startX;
								maxX = Main.maxTilesX - endX;
								break;
							case 1:
								minX = endX;
								maxX = startX;
								break;
						}
						for (int i = minX; i < maxX; i++)
						{
							for (int j = 0; (double)j < Main.worldSurface - 1.0; j++)
							{
								Tile tile1 = Main.tile[i, j];
								if (tile1.active() && (int)tile1.type == 53)
								{
									Tile tile2 = Main.tile[i, j - 1];
									if (!tile2.active() && (int)tile2.wall == 0)
									{
										if ((int)Main.tile[i, j - 2].liquid == 0 && Main.rand.Next(2) == 0)
										{
											WorldGen.PlaceObject(i, j - 1, mod.TileType("MoaiStatue"), true, 0, 0, -1, k == 0 ? 1 : -1);
											break;
										}
									}
								}
							}
						}
					}				
				}));
			}
            index = tasks.FindIndex(genPass => genPass.Name == "Gems");
            if (index != -1)
            {
                tasks.Add(new PassLegacy("[Antiaris] Nature Crystals", AddNatureCrystal));
                tasks.Add(new PassLegacy("[Antiaris] Enchanted Stones", AddStone));
            }
            index = tasks.FindIndex(x => x.Name == "Floating Islands");
            if (index != -1)
            {
                tasks.Add(new PassLegacy("[Antiaris] Pyramid", AddPyramid));
            }
            index = tasks.FindIndex(x => x.Name == "Final Cleanup");
            if (index != -1)
            {
                tasks.Add(new PassLegacy("[Antiaris] Pirate Cove", AddPirateCove));
                tasks.Add(new PassLegacy("[Antiaris] Hive Shrine", AddHiveShrine));
            }
        }

        public void AddGuideHouse(GenerationProgress progress = null)
        {
            if (GenerateHouse)
            {
                return;
            }
            try
            {
                bool Success = do_MakeGuideHouse(progress);
                if (Success)
                {
                    GenerateHouse = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddBoat(GenerationProgress progress = null)
        {
            if (GenerateBoat)
            {
                return;
            }
            try
            {
                bool Success = do_MakePirateBoat(progress);
                if (Success)
                {
                    GenerateBoat = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddStone(GenerationProgress progress = null)
        {
            if (GenerateStone)
            {
                return;
            }
            try
            {
                bool Success = do_MakeEnchantedStones(progress);
                if (Success)
                {
                    GenerateStone = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddPyramid(GenerationProgress progress = null)
        {
            if (GeneratePyramid)
            {
                return;
            }
            try
            {
                bool Success = do_MakeSandPyramid(progress);
                if (Success)
                {
                    GeneratePyramid = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddNatureCrystal(GenerationProgress progress = null)
        {
            if (GenerateCrystal)
            {
                return;
            }
            try
            {
                bool Success = do_MakeNatureCrystal(progress);
                if (Success)
                {
                    GenerateCrystal = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddSnowHouse(GenerationProgress progress = null)
        {
            if (GenerateSnowHouse)
            {
                return;
            }
            try
            {
                bool Success = do_MakeSnowHouse(progress);
                if (Success)
                {
                    GenerateSnowHouse = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddSubmarine(GenerationProgress progress = null)
        {
            if (GenerateSubmarine)
            {
                return;
            }
            try
            {
                bool Success = do_MakeSunkenSubmarine(progress);
                if (Success)
                {
                    GenerateSubmarine = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddChestFinder(GenerationProgress progress = null)
        {
            if (GenerateFinder)
            {
                return;
            }
            try
            {
                bool Success = do_MakeChestFinder(progress);
                if (Success)
                {
                    GenerateFinder = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddTower(GenerationProgress progress = null)
        {
            if (GenerateMirrorTower)
            {
                return;
            }
            try
            {
                bool Success = do_MakeTheTower(progress);
                if (Success)
                {
                    GenerateMirrorTower = true;
                }
                leaf(progress);
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddPirateCove(GenerationProgress progress = null)
        {
            if (GeneratePirateCove)
            {
				return;
            }
            try
            {
				bool Success = do_MakePirateCove(progress);
                if (Success)
                {
                    GeneratePirateCove = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public void AddHiveShrine(GenerationProgress progress = null)
        {
            if (GenerateHiveShrine)
            {
                return;
            }
            try
            {
                bool Success = do_MakeHiveShrine(progress);
                if (Success)
                {
                    GenerateHiveShrine = true;
                }
            }
            catch (Exception exception)
            {
                Main.NewText("Oh no, an error happened! Report this to Zerokk and send him the file Terraria/ModLoader/Logs/Logs.txt");
                ErrorLogger.Log(exception);
            }
        }

        public static bool do_MakeHiveShrine(GenerationProgress progress)
        {
            string HiveShrineGen = Language.GetTextValue("Mods.Antiaris.HiveShrineGen");
            if (progress != null)
            {
                progress.Message = HiveShrineGen;
                progress.Set(0.33f);
            }
            List<Point> list = new List<Point>();
            foreach (int k in HiveShrineGenTiles)
            {
                for (int i = Main.maxTilesX / 5; i < Main.maxTilesX / 5 * 4; i++)
                {
                    int y = 200;
                    while (!WorldGen.SolidOrSlopedTile(i, y + 1))
                        y++;
                    bool canBeGenerated = true;
                    for (int j = 0; j < 5; j++)
                        if (!WorldGen.SolidOrSlopedTile(i + j, y + 1) || Main.tile[i + j, y + 1].type != k)
                            canBeGenerated = false;
                    if (canBeGenerated)
                        for (int a = 0; a < 17; a++)
                            if (WorldGen.SolidOrSlopedTile(i - 1, y - a) || WorldGen.SolidOrSlopedTile(i + 5, y - a))
                                canBeGenerated = false;
                    if (canBeGenerated)
                        list.Add(new Point(i, y));
                }
                if (list.Count > 0)
                {
                    Point point = list[WorldGen.genRand.Next(0, list.Count<Point>())];
                    HiveShrinePositionX = point.X; HiveShrinePositionY = point.Y + 13;
                    goto GenerateBuild;
                }
            }
            AntiarisHelper.Log("Continue...");
            return false;

            GenerateBuild:
            AntiarisHelper.Log("Generating hive shrine...");
            Mod mod = ModLoader.GetMod("Antiaris");
            for (var X = 0; X < HiveShrineTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < HiveShrineTiles.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(HiveShrinePositionX + X, HiveShrinePositionY - Y);
                    switch (HiveShrineTiles[Y, X])
                    {
                        case 0:
                            break;
                        case 1:
                            tile.type = 225;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = 229;
                            tile.active(true);
                            break;
                        case 3:
                            WorldGen.KillTile(HiveShrinePositionX + X, HiveShrinePositionY - Y, false, false, false);
                            tile.liquid = 0;
                            break;
                        case 4:
                            WorldGen.KillTile(HiveShrinePositionX + X, HiveShrinePositionY - Y, false, false, false);
                            tile.liquidType(2);
                            tile.liquid = 255;
                            break;
                        case 5:
                            WorldGen.KillTile(HiveShrinePositionX + X, HiveShrinePositionY - Y);
                            WorldGen.PlaceTile(HiveShrinePositionX + X, HiveShrinePositionY - Y, TileID.Platforms, false, false, -1, 24);
                            break;
                    }
                    switch (HiveShrineWalls[Y, X])
                    {
                        case 1:
                            tile.wall = 86;
                            break;
                    }
                    if (HiveShrineSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(HiveShrineSlopes[Y, X]);
                    }
                }
            }
            WorldGen.PlaceChest(HiveShrinePositionX + 6, HiveShrinePositionY - 8, 21, true, 29);
            var HoneyChestIndex = Chest.FindChest(HiveShrinePositionX + 6, HiveShrinePositionY - 9);
            if (HoneyChestIndex != -1)
            {
                do_HiveShrineLoot(Main.chest[HoneyChestIndex].item);
            }
            mod.GetModWorld<AntiarisWorld>().GenerateHiveShrine = true;
            return true;
        }

        public static bool do_MakePirateCove(GenerationProgress progress)
        {
            string PirateCoveGen = Language.GetTextValue("Mods.Antiaris.PirateCoveGen");
            if (progress != null)
            {
                progress.Message = PirateCoveGen;
                progress.Set(0.33f);
            }
            int minX = (int)(Main.maxTilesX * 0.285f);
            int minY = (int)(Main.rockLayer);

            int maxTilesX = 30;
            int maxTilesY = 28;

            int maxX = (int)(Main.maxTilesX * 0.8f) - maxTilesX;
            int maxY = Main.maxTilesY - 200 - maxTilesY;

            bool generated = true;
            for (int i = -1; i < 0; i++)
                if (generated)
                {
                    PirateCovePositionX = WorldGen.genRand.Next(minX, maxX);
                    PirateCovePositionY = WorldGen.genRand.Next(minY, maxY);
                    generated = false;
                }
            for (int i = PirateCovePositionX; i < PirateCovePositionX - maxTilesX; i++)
            {
                for (int j = PirateCovePositionY; j < PirateCovePositionY - maxTilesY; j++)
                {
                    Tile tileSafely = Framing.GetTileSafely(i, j);
                    if (Main.tile[i, j].active())
                        goto Success;
                    else if (tileSafely.wall >= 231 || tileSafely.type >= 470 || tileSafely.type == TileID.LihzahrdBrick || Main.wallHouse[(int)tileSafely.wall] || WallID.Sets.Corrupt[(int)tileSafely.wall] || WallID.Sets.Crimson[(int)tileSafely.wall] || (tileSafely.active() && (TileID.Sets.BasicChest[(int)tileSafely.type] || TileID.Sets.BasicChest[(int)Framing.GetTileSafely(i, j - 1).type] || (Main.tileSolid[(int)tileSafely.type] && (TileID.Sets.Corrupt[(int)tileSafely.type] || TileID.Sets.Crimson[(int)tileSafely.type] || TileID.Sets.IcesSlush[(int)tileSafely.type] || TileID.Sets.JungleSpecial[(int)tileSafely.type] || TileID.Sets.GrassSpecial[(int)tileSafely.type])))))
                    {
                        PirateCovePositionX = WorldGen.genRand.Next(minX, maxX);
                        PirateCovePositionY = WorldGen.genRand.Next(minY, maxY);
                        generated = true;
                    }
                }
            }

            Success:
            goto GenerateBuild;
            AntiarisHelper.Log("Continue...");


			GenerateBuild:
			AntiarisHelper.Log("Generating pirate cove...");
			Mod mod = ModLoader.GetMod("Antiaris");
            for (var t = 0; t < 6; t++)
            {
                if (Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.SnowBlock || Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.IceBlock)
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 147;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 161;
                }
                else if (Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.HardenedSand)
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 397;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 396;
                }
                else if (Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.Marble)
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 367;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 367;
                }
                else if (Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.Granite)
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 368;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 368;
                }
                else if (Main.tile[PirateCovePositionX, PirateCovePositionY + t].type == TileID.Mud)
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 59;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 1;
                }
                else
                {
					mod.GetModWorld<AntiarisWorld>().CoveBlock1 = 0;
					mod.GetModWorld<AntiarisWorld>().CoveBlock2 = 1;
                }
            }
            for (var X = 0; X < PirateCoveTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < PirateCoveTiles.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(PirateCovePositionX + X, PirateCovePositionY - Y);
                    switch (PirateCoveTiles[Y, X])
                    {
                        case 0:
                            break;
                        case 1:
                            tile.type = (ushort)mod.GetModWorld<AntiarisWorld>().CoveBlock1;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = (ushort)mod.GetModWorld<AntiarisWorld>().CoveBlock2;
                            tile.active(true);
                            break;  
                        case 3:
                            tile.type = 30;
                            tile.active(true);
                            break;
                        case 4:
                            WorldGen.KillTile(PirateCovePositionX + X, PirateCovePositionY - Y);
                            WorldGen.PlaceTile(PirateCovePositionX + X, PirateCovePositionY - Y, TileID.Platforms, false, false, -1, 0);
                            break;
                        case 5:
                            tile.type = 213;
                            tile.active(true);
                            break;
                        case 6:
                            tile.type = 51;
                            tile.active(true);
                            break;
                        case 7:
                            WorldGen.KillTile(PirateCovePositionX + X, PirateCovePositionY - Y, false, false, false);
							tile.liquid = 0;
                            break;
                        case 8:
                            WorldGen.KillTile(PirateCovePositionX + X, PirateCovePositionY - Y, false, false, false);
                            tile.liquid = 255;
                            break;
                        case 9:
                            tile.type = 332;
                            tile.active(true);
                            break;
                    }
                    switch (PirateCoveWalls[Y, X])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = 4;
                            break;
                        case 2:
                            tile.wall = 63;
                            break;
                        case 3:
                            break;
                    }
                    if (PirateCoveSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(PirateCoveSlopes[Y, X]);
                    }
                }
            }
            WorldGen.PlaceObject(PirateCovePositionX + 7, PirateCovePositionY - 10, 376, true);
            WorldGen.PlaceObject(PirateCovePositionX + 19, PirateCovePositionY - 10, 376, true);
            WorldGen.PlaceObject(PirateCovePositionX + 15, PirateCovePositionY - 1, 376, true);
            WorldGen.PlaceObject(PirateCovePositionX + 10, PirateCovePositionY - 20, 42, true, 2);
            WorldGen.PlaceObject(PirateCovePositionX + 10, PirateCovePositionY - 10, 93, true, 15);
            WorldGen.PlaceObject(PirateCovePositionX + 13, PirateCovePositionY - 10, 93, true, 15);
            WorldGen.PlaceObject(PirateCovePositionX + 8, PirateCovePositionY - 10, ModLoader.GetMod("Antiaris").TileType("GildedStrongbox"));
            WorldGen.PlaceObject(PirateCovePositionX + 12, PirateCovePositionY - 1, ModLoader.GetMod("Antiaris").TileType("GildedStrongbox"));
            WorldGen.PlaceObject(PirateCovePositionX + 7, PirateCovePositionY - 12, ModLoader.GetMod("Antiaris").TileType("GildedCrate"));
            WorldGen.PlaceObject(PirateCovePositionX + 21, PirateCovePositionY - 10, ModLoader.GetMod("Antiaris").TileType("GildeCrate"));
            WorldGen.PlaceObject(PirateCovePositionX + 17, PirateCovePositionY - 1, ModLoader.GetMod("Antiaris").TileType("GildedCrate"));
            WorldGen.PlaceObject(PirateCovePositionX + 21, PirateCovePositionY - 10, ModLoader.GetMod("Antiaris").TileType("GildedCrate"));
            WorldGen.PlaceObject(PirateCovePositionX + 18, PirateCovePositionY - 12, ModLoader.GetMod("Antiaris").TileType("GildedStrongbox"));
            WorldGen.PlaceObject(PirateCovePositionX + 2, PirateCovePositionY - 22, ModLoader.GetMod("Antiaris").TileType("GildedCup"));
            WorldGen.PlaceObject(PirateCovePositionX + 15, PirateCovePositionY - 3, ModLoader.GetMod("Antiaris").TileType("GildedCup"));
            WorldGen.PlaceObject(PirateCovePositionX + 26, PirateCovePositionY - 16, ModLoader.GetMod("Antiaris").TileType("GildedCup"));
            WorldGen.PlaceChest(PirateCovePositionX + 11, PirateCovePositionY - 10, (ushort)ModLoader.GetMod("Antiaris").TileType("GildedChest"), false, 2);
            var PirateChestIndex = Chest.FindChest(PirateCovePositionX + 11, PirateCovePositionY - 11);
            if (PirateChestIndex != -1)
            {
                do_PirateCoveLoot(Main.chest[PirateChestIndex].item);
            }
			mod.GetModWorld<AntiarisWorld>().GeneratePirateCove = true;
            return true;
        }

        bool do_MakeSnowHouse(GenerationProgress progress)
        {
			string SnowHouseGen = Language.GetTextValue("Mods.Antiaris.SnowHouseGen");
			if (progress != null)
			{
				progress.Message = SnowHouseGen;
				progress.Set(0.33f);
			}
			List<Point> list = new List<Point>();
			foreach (int k in SnowHouseGenTiles)
			{
				for (int i = Main.maxTilesX / 5; i < Main.maxTilesX / 5 * 4; i++)
				{
					int y = 200;
					while (!WorldGen.SolidOrSlopedTile(i, y + 1))
						y++;
					bool canBeGenerated = true;
					for (int j = 0; j < 33; j++)
						if (!WorldGen.SolidOrSlopedTile(i + j, y + 1) || Main.tile[i + j, y + 1].type != k)
							canBeGenerated = false;
					if (canBeGenerated)
						for (int a = 0; a < 17; a++)
							if (WorldGen.SolidOrSlopedTile(i - 1, y - a) || WorldGen.SolidOrSlopedTile(i + 33, y - a))
								canBeGenerated = false;
						if (canBeGenerated)
							list.Add(new Point(i, y));
				}
				if (list.Count > 0)
				{
					Point point = list[WorldGen.genRand.Next(0, list.Count<Point>())];
					SnowHousePositionX = point.X; SnowHousePositionY = point.Y;
					goto GenerateBuild;
				}
			}
			AntiarisHelper.Log("Continue...");
            return false;

            GenerateBuild:
            AntiarisHelper.Log("Generating snow house...");
            var SpawnAdventurer = NPC.NewNPC((SnowHousePositionX + 17) * 16, (SnowHousePositionY - 5) * 16, ModLoader.GetMod("Antiaris").NPCType("FrozenAdventurer"), 0, 0f, 0f, 0f, 0f, 255);
            Main.npc[SpawnAdventurer].homeTileX = -1;
            Main.npc[SpawnAdventurer].homeTileY = -1;
            Main.npc[SpawnAdventurer].direction = 1;
            Main.npc[SpawnAdventurer].homeless = false;
            for (var X = 0; X < SnowHouseTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < SnowHouseTiles.GetLength(0); Y++)
                {
					var tile = Framing.GetTileSafely(SnowHousePositionX + X, SnowHousePositionY - Y);
                    switch (SnowHouseTiles[Y, X])
                    {
                        case 0:
                            break;
                        case 1:
                            tile.type = 147;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = 321;
                            tile.active(true);
                            break;
						case 3:
                            tile.type = 124;
                            tile.active(true);
                            break;
						case 4:
                            tile.type = 54;
                            tile.active(true);
                            break;
						case 5:
                            WorldGen.KillTile(SnowHousePositionX + X, SnowHousePositionY - Y);
                            WorldGen.PlaceTile(SnowHousePositionX + X, SnowHousePositionY - Y, TileID.Platforms, false, false, -1, 19);
                            break;
						case 6:
                            tile.type = 51;
							tile.active(true);
                            break;
                        case 7:
                            WorldGen.KillTile(SnowHousePositionX + X, SnowHousePositionY - Y, false, false, false);
                            break;
                    }
                    switch (SnowHouseWalls[Y, X])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = 149;
                            break;
                        case 2:
                            tile.wall = 4;
                            break;
                        case 3:
                            tile.wall = 78;
                            break;
						case 4:
                            tile.wall = 150;
                            break;
						case 5:
                            tile.wall = 21;
                            break;
                    }
                    if (SnowHouseSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(SnowHouseSlopes[Y, X]);
                    }
                }
            }
			WorldGen.PlaceObject(SnowHousePositionX + 11, SnowHousePositionY - 5, 10, true, 30);
			WorldGen.PlaceObject(SnowHousePositionX + 18, SnowHousePositionY - 8, 50, true);
			WorldGen.PlaceObject(SnowHousePositionX + 19, SnowHousePositionY - 8, 78, true);
			WorldGen.PlaceObject(SnowHousePositionX + 25, SnowHousePositionY - 5, TileID.Chairs, true, 30, 1);
			WorldGen.PlaceObject(SnowHousePositionX + 23, SnowHousePositionY - 7, ModLoader.GetMod("Antiaris").TileType("BrothersPenguins"));
			WorldGen.PlaceObject(SnowHousePositionX + 19, SnowHousePositionY - 5, ModLoader.GetMod("Antiaris").TileType("SnowSofa"));
			WorldGen.PlaceObject(SnowHousePositionX + 13, SnowHousePositionY - 5, ModLoader.GetMod("Antiaris").TileType("SnowWorkBench"));
			WorldGen.PlaceObject(SnowHousePositionX + 23, SnowHousePositionY - 5, ModLoader.GetMod("Antiaris").TileType("SnowFireplace"));
			WorldGen.PlaceObject(SnowHousePositionX + 6, SnowHousePositionY - 3, ModLoader.GetMod("Antiaris").TileType("SteelShovel"));
			WorldGen.PlaceChest(SnowHousePositionX + 19, SnowHousePositionY - 11, 21, true);
			var SnowChestIndex = Chest.FindChest(SnowHousePositionX + 19, SnowHousePositionY - 12);
            if (SnowChestIndex != -1)
            {
				do_SnowHouseLoot(Main.chest[SnowChestIndex].item);
            }
            return true;
        }

        bool do_MakeGuideHouse(GenerationProgress progress)
        {
			string GuideHouseGen = Language.GetTextValue("Mods.Antiaris.GuideHouseGen");
            if (progress != null)
            {
                progress.Message = GuideHouseGen;
                progress.Set(0.1f);
            }
			var startX = Main.maxTilesX / 2 + 5;
            var endX = Main.spawnTileX + 50;
            StartPositionX = 0;
            StartPositionY = 0;
            for (var attempts = 0; attempts < 10000; attempts++)
            {
                StartPositionX = WorldGen.genRand.Next(startX, endX);
                StartPositionY = 200;
                do
                {
                    StartPositionY++;
                }
                while (!Main.tile[StartPositionX, StartPositionY].active() && StartPositionY < Main.worldSurface);
                if (Main.tile[StartPositionX, StartPositionY].active() && (Main.tile[StartPositionX, StartPositionY].type == TileID.Dirt || Main.tile[StartPositionX, StartPositionY].type == TileID.Grass) && AntiarisHelper.GetLiquidLevel(StartPositionX, StartPositionY - 1, LiquidType.Water) <= 0)
                {
                    goto GenerateBuild;
                }
            }
            AntiarisHelper.Log("Continue...");
            return false;

            GenerateBuild:
            AntiarisHelper.Log("Generating guide house...");
            var SpawnGuide = NPC.NewNPC((StartPositionX + 15) * 16, (StartPositionY - 6) * 16, ModLoader.GetMod("Antiaris").NPCType("UnconsciousGuide"), 0, 0f, 0f, 0f, 0f, 255);
            Main.npc[SpawnGuide].homeTileX = -1;
            Main.npc[SpawnGuide].homeTileY = -1;
            Main.npc[SpawnGuide].direction = 1;
            Main.npc[SpawnGuide].homeless = false;
            for (var t = 0; t < 6; t++)
            {
                if (Main.tile[StartPositionX, StartPositionY + t].type == TileID.SnowBlock)
                {
                    CheckTile = TileID.SnowBlock;
                    ChestType = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealWoodCabinet");
                    Bed = 24;
                    Wood = 321;
                    WoodWall = 149;
                    StoneWall = 84;
                    Brick = 206;
                    WoodTile = 150;
                    Table = 28;
                    Door = 30;
                    Platform = 19;
                    Chair = 60;
                    Stone = TileID.IceBlock;
                    Grass = TileID.SnowBlock;
                    Fence = WallID.BorealWoodFence;
                    Mailbox = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealMailbox");
                    Dray = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealLeafDray");
                }
                if (Main.tile[StartPositionX, StartPositionY + t].type == TileID.Dirt)
                {
                    CheckTile = TileID.Dirt;
                    ChestType = (ushort)ModLoader.GetMod("Antiaris").TileType("Cabinet");
                    Bed = 0;
                    Wood = TileID.WoodBlock;
                    WoodWall = 4;
                    StoneWall = 5;
                    Brick = 38;
                    WoodTile = 106;
                    Door = 0;
                    Table = 0;
                    Platform = 0;
                    Chair = 0;
                    Mailbox = (ushort)ModLoader.GetMod("Antiaris").TileType("Mailbox");
                    Stone = TileID.Stone;
                    Grass = 2;
                    Fence = 106;
                    Dray = (ushort)ModLoader.GetMod("Antiaris").TileType("LeafDray");
                }
                if (Main.tile[StartPositionX, StartPositionY + t].type == TileID.IceBlock)
                {
                    CheckTile = TileID.SnowBlock;
                    ChestType = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealWoodCabinet");
                    Mailbox = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealMailbox");
                    Bed = 24;
                    Wood = 321;
                    WoodWall = 149;
                    StoneWall = 84;
                    Brick = 206;
                    WoodTile = 150;
                    Table = 28;
                    Door = 60;
                    Platform = 19;
                    Chair = 30;
                    Stone = TileID.IceBlock;
                    Grass = TileID.SnowBlock;
                    Fence = WallID.BorealWoodFence;
                    Dray = (ushort)ModLoader.GetMod("Antiaris").TileType("BorealLeafDray");
                }
            }
            StartPositionY += 3;
            for (var X = 0; X < GuideHouse.GetLength(1); X++)
            {
                for (var Y = 0; Y < GuideHouse.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(StartPositionX + X, StartPositionY - Y);
                    switch (GuideHouse[Y, X])
                    {
                        case 0:
                            break;
                        case 1:
                            tile.type = (ushort)CheckTile;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = (ushort)Wood;
                            tile.active(true);
                            break;
                        case 3:
                            tile.type = (ushort)Brick;
                            tile.active(true);
                            break;
                        case 4:
                            tile.type = (ushort)Stone;
                            tile.active(true);
                            break;
						case 5:
							WorldGen.PlaceTile(StartPositionX + X, StartPositionY - Y, TileID.Platforms, true, true, -1, Platform);
							break;
						case 6:
                            tile.type = (ushort)StoneSlab;
                            tile.active(true);
                            break;
						case 7:
                            tile.type = (ushort)Grass;
                            tile.active(true);
                            break;
                        case 8:
                            WorldGen.KillTile(StartPositionX + X, StartPositionY - Y, false, false, false);
                            break;
                    }
                    switch (GuideHouseWall[Y, X])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = (ushort)StoneWall;
                            break;
                        case 2:
                            tile.wall = (ushort)WoodWall;
                            break;
                        case 3:
                            tile.wall = (ushort)LivingWoodWall;
                            break;
						case 4:
							tile.wall = (ushort)PlankedWall;
							break;
						case 5:
							tile.wall = (ushort)StoneSlabWall;
							break;
						case 6:
							tile.wall = (ushort)Fence;
							break;
                    }
                    if (GuideHouseSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(GuideHouseSlopes[Y, X]);
                    }
					WorldGen.PlaceObject(StartPositionX + 11, StartPositionY - 13, 79, true, Bed);
					WorldGen.PlaceChest(StartPositionX + 14, StartPositionY - 13, (ushort)ChestType);
					var ChestIndex2 = Chest.FindChest(StartPositionX + 14, StartPositionY - 14);
                    if (ChestIndex2 != -1)
                    {
                        do_GuideHouseLoot2(Main.chest[ChestIndex2].item);
                    }
					WorldGen.PlaceObject(StartPositionX + 11, StartPositionY - 11, 42, true, 3);
					WorldGen.PlaceObject(StartPositionX + 14, StartPositionY - 15, 78, true);
					WorldGen.PlaceObject(StartPositionX + 8, StartPositionY - 5, 387, true);
					WorldGen.PlaceObject(StartPositionX + 11, StartPositionY - 6, 14, true, Table);
					WorldGen.PlaceObject(StartPositionX + 11, StartPositionY - 8, 103, true);
					WorldGen.PlaceObject(StartPositionX + 8, StartPositionY - 10, 50, true);
					WorldGen.PlaceObject(StartPositionX + 9, StartPositionY - 10, 13, true, 1);
					WorldGen.PlaceObject(StartPositionX + 15, StartPositionY - 10, 246, true, 3);
					WorldGen.PlaceObject(StartPositionX + 1, StartPositionY - 5, Mailbox);
					WorldGen.PlaceObject(StartPositionX + 22, StartPositionY - 6, Dray);
					WorldGen.PlaceObject(StartPositionX + 19, StartPositionY - 6, 10, true, Door);
                    WorldGen.KillTile(StartPositionX + 11, StartPositionY - 2, false, false, true);
                    WorldGen.KillTile(StartPositionX + 12, StartPositionY - 2, false, false, true);
                    WorldGen.KillTile(StartPositionX + 11, StartPositionY - 3, false, false, true);
                    WorldGen.KillTile(StartPositionX + 12, StartPositionY - 3, false, false, true);
                    WorldGen.KillTile(StartPositionX + 10, StartPositionY - 2, false, false, true);
                    WorldGen.KillTile(StartPositionX + 9, StartPositionY - 2, false, false, true);
                    WorldGen.KillTile(StartPositionX + 10, StartPositionY - 3, false, false, true);
                    WorldGen.KillTile(StartPositionX + 9, StartPositionY - 3, false, false, true);
                    WorldGen.KillTile(StartPositionX + 8, StartPositionY - 2, false, false, true);
                    WorldGen.KillTile(StartPositionX + 8, StartPositionY - 3, false, false, true);
                    WorldGen.PlaceChest(StartPositionX + 11, StartPositionY - 2, 21, true, 28);
					var ChestIndex1 = Chest.FindChest(StartPositionX + 11, StartPositionY - 3);
                    if (ChestIndex1 != -1)
                    {
                        do_GuideHouseLoot(Main.chest[ChestIndex1].item);
                    }
                }
            }
            return true;
        }

        bool do_MakePirateBoat(GenerationProgress progress)
        {
			string PirateBoatGen = Language.GetTextValue("Mods.Antiaris.PirateBoatGen");
            if (progress != null)
            {
                progress.Message = PirateBoatGen;
                progress.Set(0.33f);
            }      
            for (var Attempts = 0; Attempts < 10000; Attempts++)
            {
                BoatPositionX = 75;
                BoatPositionY = 0;
                do
                {
                    BoatPositionY++;
                }
                while (Main.tile[BoatPositionX, BoatPositionY].liquid < 1);
                if (Main.tile[BoatPositionX, BoatPositionY].liquid > 0)
                {        
                    goto GenerateBuild;
                }
            }
            AntiarisHelper.Log("Continue...");
            return false;

            GenerateBuild:
            AntiarisHelper.Log("Generating pirate boat...");
            var SpawnPirate = NPC.NewNPC((BoatPositionX + 5) * 16, (BoatPositionY - 2) * 16, ModLoader.GetMod("Antiaris").NPCType("BoundPirate"), 0, 0f, 0f, 0f, 0f, 255);
            Main.npc[SpawnPirate].homeTileX = -1;
            Main.npc[SpawnPirate].homeTileY = -1;
            Main.npc[SpawnPirate].direction = 1;
            Main.npc[SpawnPirate].homeless = false;
            for (var X = 0; X < BoatTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < BoatTiles.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(BoatPositionX + X, BoatPositionY + 2 - Y);
                    if (tile.liquid > 0)
                        tile.liquid = 0;
                    switch (BoatTiles[Y, X])
                    {
                        case 0:
                            tile.active(false);
                            break;
                        case 1:
                            tile.type = (ushort)(!WorldGen.crimson ? 157 : 208);
                            tile.active(true);
                            tile.color(28);
                            break;
                        case 2:
                            tile.type = 124;
                            tile.active(true);
                            break;
                    }
                    switch (BoatWalls[Y, X])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = (ushort)(!WorldGen.crimson ? 41 : 85);
                            tile.wallColor(28);
                            break;
                        case 2:
                            tile.wall = (ushort)(!WorldGen.crimson ? 138 : 141); ;
                            tile.wallColor(28);
                            break;
                        case 3:
                            tile.wall = 148;
                            break;
                    }
                    if (BoatSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(BoatSlopes[Y, X]);
                    }
                    if (BoatNoneActive[Y, X] == 1)
                    {	
                        tile.inActive(true);
                    }
                    else
                    {
                        tile.inActive(false);
                    }
                }
            }
            for (var X = 0; X < BoatTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < BoatTiles.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(BoatPositionX + X, BoatPositionY + 2 - Y);
                    switch (BoatObjects[Y, X])
                    {
                        case 0:
                            break;
                        case 1:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, 42, true, 6);
                            break;
                        case 2:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, TileID.TrapdoorClosed);
                            break;
                        case 3:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, 42, true, 4);
                            break;
                        case 4:
                            WorldGen.PlaceTile(BoatPositionX + X, BoatPositionY + 2 - Y, TileID.Platforms, true, true, -1, (ushort)(!WorldGen.crimson ? 1 : 5));
                            tile.color(28);
                            break;
                        case 5:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, 376);
                            break;
                        case 6:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, 101);
                            break;
                        case 7:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, TileID.Kegs);
                            break;
                        case 8:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, 13);
                            break;
                        case 9:
                            WorldGen.PlaceChest(BoatPositionX + X, BoatPositionY + 2 - Y, 21, false, 5);
                            var ChestIndex = Chest.FindChest(BoatPositionX + X, BoatPositionY + 1 - Y);
                            if (ChestIndex != -1)
                            {
                                do_PirateBoatLoot(Main.chest[ChestIndex].item);
                            }
                            break;
                        case 10:
                            WorldGen.PlaceObject(BoatPositionX + X, BoatPositionY + 2 - Y, ModLoader.GetMod("Antiaris").TileType("DeadManChest"));
                            break;
                    }
                }
            }
            return true;
        }

        bool do_MakeEnchantedStones(GenerationProgress progress)
        {
            string EnchantedGen = Language.GetTextValue("Mods.Antiaris.EnchantedGen");
            if (progress != null)
            {
                progress.Message = EnchantedGen;
                progress.Set(0.41f);
            }
            goto GenerateEnchanted;
            AntiarisHelper.Log("Continue...");
            return false;

            GenerateEnchanted:
            AntiarisHelper.Log("Generating enchanted stones...");
            for (var j = 0.0; j < (double)((Main.maxTilesX - 200) * (int)((double)Main.maxTilesY * 0.300000011920929)) / 7250.0; ++j)
            {
				var x = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
				var y = WorldGen.genRand.Next((int)((double)Main.maxTilesY * 0.349999994039536), Main.maxTilesY - 300);
				if ((int)Main.tile[x, y].type != 44 && (int)Main.tile[x, y].type != 41 && (int)Main.tile[x, y].type != 226 && (int)Main.tile[x, y].type != 43 && (int)Main.tile[x, y].type != 314 && (int)Main.tile[x, y].type != 53 && (int)Main.tile[x, y].type != 147 && (int)Main.tile[x, y].type != 161 && (int)Main.tile[x, y].type != 59)
				{
					WorldGen.TileRunner(x, y, (double)WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), (ushort)ModLoader.GetMod("Antiaris").TileType("EnchantedStone"), false, 0.0f, 0.0f, false, true);
				}
            }
            return true;
        }

        bool do_MakeSandPyramid(GenerationProgress progress)
        {
            string PyramideGen = Language.GetTextValue("Mods.Antiaris.PyramideGen");
            if (progress != null)
            {
                progress.Message = PyramideGen;
                progress.Set(0.62f);
            }
            PyramidPositionX = WorldGen.genRand.Next(WorldGen.UndergroundDesertLocation.X - 25, WorldGen.UndergroundDesertLocation.X + 200);
            PyramidPositionY = 185;
            for (var Attempts = 0; Attempts < 10000; Attempts++)
            {
                for (var X = PyramidPositionX - 20; X < PyramidPositionX + 20; X++)
                {
                    for (var Y = PyramidPositionY - 20; Y < PyramidPositionY + 20; Y++)
                    {
                        if (Main.tile[X, Y].active() || Main.tile[X, Y].wall != 0)
                        {
                            goto NextAttempt;
                        }
                    }
                }
                goto Pyramid;
                NextAttempt:;
            }
            AntiarisHelper.Log("Continue...");
            return false;

            Pyramid:
            AntiarisHelper.Log("Generating pyramid...");
            for (var X = 0; X < PyramidTiles.GetLength(1); X++)
            {
                for (var Y = 0; Y < PyramidTiles.GetLength(0); Y++)
                {
                    var tile = Framing.GetTileSafely(PyramidPositionX + X, PyramidPositionY - Y);
                    if (Framing.GetTileSafely(PyramidPositionX + X + 1, PyramidPositionY - Y).active() && Framing.GetTileSafely(PyramidPositionX + X - 1, PyramidPositionY - Y).active() && Framing.GetTileSafely(PyramidPositionX + X, PyramidPositionY - Y + 1).active() && Framing.GetTileSafely(PyramidPositionX + X, PyramidPositionY - Y - 1).active())
                    {
                        WorldGen.PlaceWall(PyramidPositionX + X, PyramidPositionY - Y, 73);
                    }
                    switch (PyramidTiles[Y, X])
                    {
                        case 0:
                            if (tile.liquid > 0)
                                tile.liquid = 0;
                            WorldGen.KillTile(PyramidPositionX + X, PyramidPositionY - Y, false, false, true);
                            break;
                        case 1:
                            WorldGen.KillTile(PyramidPositionX + X, PyramidPositionY - Y, false, false, true);
                            break;
                        case 2:
                            tile.type = 151;
                            tile.active(true);
                            break;
                        case 3:
                            tile.type = TileID.Sand;
                            tile.active(true);
                            break;
                        case 4:
                            tile.type = 189;
                            tile.active(true);
                            break;
                        case 5:
                            tile.type = 404;
                            tile.active(true);
                            break;
                    }
                    switch (PyramidWalls[Y, X])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = 34;
                            break;
                        case 2:
                            tile.wall = 73;
                            break;
                    }
                    if (PyramidSlopes[Y, X] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(PyramidSlopes[Y, X]);
                    }
                    WorldGen.PlaceChest(PyramidPositionX + 30, PyramidPositionY - 28, 21, true, 1);
                    var ChestIndex = Chest.FindChest(PyramidPositionX + 30, PyramidPositionY - 29);
                    if (ChestIndex != -1)
                    {
                        do_PyramidLoot(Main.chest[ChestIndex].item);
                    }
                    WorldGen.PlaceObject(PyramidPositionX + 26, PyramidPositionY - 24, 91, true, 4);
                    WorldGen.PlaceObject(PyramidPositionX + 35, PyramidPositionY - 24, 91, true, 5);
                    WorldGen.PlaceObject(PyramidPositionX + 27, PyramidPositionY - 21, 135);
                    WorldGen.PlaceObject(PyramidPositionX + 34, PyramidPositionY - 21, 135);
                    Main.tile[PyramidPositionX + 27, PyramidPositionY - 18].active(false);
                    Main.tile[PyramidPositionX + 28, PyramidPositionY - 18].active(false);
                    Main.tile[PyramidPositionX + 33, PyramidPositionY - 18].active(false);
                    Main.tile[PyramidPositionX + 34, PyramidPositionY - 18].active(false);
                    WorldGen.PlaceObject(PyramidPositionX + 27, PyramidPositionY - 18, 443);
                    WorldGen.PlaceObject(PyramidPositionX + 33, PyramidPositionY - 18, 443);
                    Main.tile[PyramidPositionX + 27, PyramidPositionY - 21].wire(true);
                    Main.tile[PyramidPositionX + 27, PyramidPositionY - 20].wire(true);
                    Main.tile[PyramidPositionX + 27, PyramidPositionY - 19].wire(true);
                    Main.tile[PyramidPositionX + 27, PyramidPositionY - 18].wire(true);
                    Main.tile[PyramidPositionX + 34, PyramidPositionY - 21].wire(true);
                    Main.tile[PyramidPositionX + 34, PyramidPositionY - 20].wire(true);
                    Main.tile[PyramidPositionX + 34, PyramidPositionY - 19].wire(true);
                    Main.tile[PyramidPositionX + 34, PyramidPositionY - 18].wire(true);
                    WorldGen.PlaceWall(PyramidPositionX + 27, PyramidPositionY - 18, 34);
                    WorldGen.PlaceWall(PyramidPositionX + 28, PyramidPositionY - 18, 34);
                    WorldGen.PlaceWall(PyramidPositionX + 33, PyramidPositionY - 18, 34);
                    WorldGen.PlaceWall(PyramidPositionX + 34, PyramidPositionY - 18, 34);
                    WorldGen.PlantCactus(PyramidPositionX + 9, PyramidPositionY - 22);
                    WorldGen.PlantCactus(PyramidPositionX + 14, PyramidPositionY - 21);
                    WorldGen.PlantCactus(PyramidPositionX + 3, PyramidPositionY - 21);
                    WorldGen.PlantCactus(PyramidPositionX + 48, PyramidPositionY - 21);
                    WorldGen.PlantCactus(PyramidPositionX + 59, PyramidPositionY - 21);
                }
            }
            return true;
        }

        bool do_MakeNatureCrystal(GenerationProgress progress)
        {
            string CrystalGen = Language.GetTextValue("Mods.Antiaris.CrystalGen");
            if (progress != null)
            {
                progress.Message = CrystalGen;
                progress.Set(0.79f);
            }
            AntiarisHelper.Log("Generating nature crystals...");
            goto GenerateCrystal;
            AntiarisHelper.Log("Continue...");
            return false;

            //thanks graydee
            GenerateCrystal:
            var X = 1;
            var Y = 1;
            var widthScale = (Main.maxTilesX / 4200f);
            var numberToGenerate = 3;
            for (var k = 0; k < numberToGenerate; k++)
            {
                var placement = false;
                var placed = false;
                while (!placed)
                {
                    var success = false;
                    var attempts = 0;
                    while (!success)
                    {
                        attempts++;
                        if (attempts > 1000)
                        {
                            success = true;
                            continue;
                        }
                        var i = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
                        if (i <= Main.maxTilesX / 2 - 50 || i >= Main.maxTilesX / 2 + 50)
                        {
                            var j = 0;
                            while (!Main.tile[i, j].active() && (double)j < Main.worldSurface)
                            {
                                j++;
                            }
                            if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 0)
                            {
                                j--;
                                if (j > 150)
                                {
                                    placement = AntiarisHelper.Placement(i, j);
                                    if (placement)
                                    {
                                        X = i;
                                        Y = j;
                                        for (var I = 0; I < 250; I++)
                                        {
                                            var why = Main.rand.Next(-15, 15);
                                            var ex = Main.rand.Next(-40, 40);
                                            WorldGen.PlaceObject(i + ex, j + why, ModLoader.GetMod("Antiaris").TileType("NatureCrystal"));
                                        }
                                        success = true;
                                        placed = true;
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        bool leaf(GenerationProgress progress)
        {
            goto GenerateLeaf;
            AntiarisHelper.Log("Continue...");
            return false;

            //thanks graydee
            GenerateLeaf:
            var X = 1;
            var Y = 1;
            var widthScale = (Main.maxTilesX / 4200f);
            var numberToGenerate = 65 * widthScale;
            for (var k = 0; k < numberToGenerate; k++)
            {
                var placed = false;
                while (!placed)
                {
                    var success = false;
                    var attempts = 0;
                    while (!success)
                    {
                        attempts++;
                        if (attempts > 1000)
                        {
                            success = true;
                            continue;
                        }
                        var i = WorldGen.genRand.Next(250, Main.maxTilesX - 250);
                        var j = 0;
                        while (!Main.tile[i, j].active() && (double)j < Main.worldSurface)
                        {
                            j++;
                        }
                        if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 0)
                        {
                            j--;
                            if (j > 150)
                            {
                                X = i;
                                Y = j;
                                WorldGen.PlaceWall(i, j + 1, 60);
                                WorldGen.PlaceWall(i - 1, j + 1, 60);
                                WorldGen.PlaceWall(i, j, 60);
                                WorldGen.PlaceWall(i + 1, j, 60);
                                success = true;
                                placed = true;
                                continue;
                            }
                        }
                    }
                }
            }
            return true;
        }

        bool do_MakeSunkenSubmarine(GenerationProgress progress)
        {
            string SubmarineGen = Language.GetTextValue("Mods.Antiaris.SubmarineGen");
            if (progress != null)
            {
                progress.Message = SubmarineGen;
                progress.Set(0.89f);
            }
            AntiarisHelper.Log("Generating submarine...");
            var startX = Main.maxTilesX - 200;
            var endX = Main.maxTilesX - 50;
            var subX = 0;
            var subY = 0;
            for (var attempts = 0; attempts < 10000; attempts++)
            {
                subX = WorldGen.genRand.Next(startX, endX);
                subY = 200;
                do
                {
                    subY++;
                }
                while (!Main.tile[subX, subY].active() && subY < Main.worldSurface);
                if (Main.tile[subX, subY].active() && Main.tile[subX, subY].type == TileID.Sand && AntiarisHelper.GetLiquidLevel(subX, subY - 1, LiquidType.Water) > 0)
                {
                    goto Success;
                }
            }
            AntiarisHelper.Log("Continue...");
            return false;

            Success:
            bool copper = WorldGen.CopperTierOre == 7;
			bool iron = WorldGen.IronTierOre == 6;
            for (var x = 0; x < SubmarineTiles.GetLength(1); x++)
            {
                for (var y = 0; y < SubmarineTiles.GetLength(0); y++)
                {
                    var tile = Framing.GetTileSafely(subX - 12 + x, subY - 12 + y);
                    tile.liquid = 255;
                    tile.liquidType(0);
                    switch (SubmarineTiles[y, x])
                    {
                        case 0:
                            tile.active(false);
                            break;
                        case 1:
                            tile.type = copper ? TileID.CopperPlating : TileID.TinPlating;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = TileID.Sand;
                            tile.active(true);
                            break;
                        case 3:
                            WorldGen.PlaceTile(x, y, TileID.Platforms, true, true, -1, 21);
                            break;
                        case 4:
                            tile.type = TileID.TopazGemsparkOff;
                            tile.active(true);
                            break;
                        case 5:
                        case 6:
                        case 7:
                            tile.ClearTile();
                            WorldGen.PlaceObject(x, y, TileID.LogicSensor, true, SubmarineTiles[y, x] - 2);
                            break;
                    }
                    if (SubmarineSlopes[y, x] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(SubmarineSlopes[y, x]);
                    }
                    switch (SubmarineWalls[y, x])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = copper ? WallID.CopperPlating : WallID.TinPlating;
                            break;
                        case 2:
                            tile.wall = WallID.StoneSlab;
                            break;
                        case 3:
                            tile.wall = (ushort)(WorldGen.genRand.NextBool(2, 3) ? WallID.Glass : 0);
                            break;
                    }
                }
            }
            for (var x = 0; x < SubmarineTiles.GetLength(1); x++)
            {
                for (var y = 0; y < SubmarineTiles.GetLength(0); y++)
                {
                    switch (SubmarineObjects[y, x])
                    {
                        case 1:
                            WorldGen.PlaceObject(subX - 12 + x, subY - 12 + y, (ushort)ModLoader.GetMod("Antiaris").TileType("Compressor"), true);
                            break;
                        case 2:
                            var i = WorldGen.PlaceChest(subX - 12 + x, subY - 12 + y, (ushort)ModLoader.GetMod("Antiaris").TileType("SunkenChest"));
                            if (i != -1)
                            {
                                do_SunkenSubmarineLoot(Main.chest[i]);
                            }
                            break;
                        case 3:
                            WorldGen.PlaceObject(subX - 12 + x, subY - 12 + y, TileID.ClosedDoor, true, iron ? 15 : 14);
                            break;
                        case 4:
                            WorldGen.PlaceObject(subX - 12 + x, subY - 12 + y, TileID.TrapdoorClosed);
                            break;
                    }
                }
            }
            if (progress == null)
            {
                for (var x = subX - 12; x <= subX + 12; x++)
                {
                    for (var y = subY - 12; y <= subY; y++)
                    {
                        WorldGen.SquareTileFrame(x, y);
                        WorldGen.SquareWallFrame(x, y);
                    }
                }
            }
            return true;
        }

        bool do_MakeTheTower(GenerationProgress progress)
		{
		    string TowerGen = Language.GetTextValue("Mods.Antiaris.TowerGen");
            if (progress != null)
            {
                progress.Message = TowerGen;
                progress.Set(0.96f);
            }
			AntiarisHelper.Log("Generating the tower...");
			
			var startX = 200;
            var endX = Main.maxTilesX - 200;
            TowerPositionX = 0;
            TowerPositionY = 0;
            for (var attempts = 0; attempts < 10000; attempts++)
            {
                TowerPositionX = WorldGen.genRand.Next(startX, endX);
                TowerPositionY = 200;
                do
                {
                    TowerPositionY++;
                }
                while (!Main.tile[TowerPositionX, TowerPositionY].active() && TowerPositionY < Main.worldSurface);
                if (Main.tile[TowerPositionX, TowerPositionY].active() && (Main.tile[TowerPositionX, TowerPositionY].type == 23 || Main.tile[TowerPositionX, TowerPositionY].type == 199) && AntiarisHelper.GetLiquidLevel(TowerPositionX, TowerPositionY - 1, LiquidType.Water) <= 0)
                {
                    goto Success;
                }
            }
            AntiarisHelper.Log("Continue...");
            return false;

			Success:
			var SpawnMirror = NPC.NewNPC((TowerPositionX + 5) * 16, (TowerPositionY - 19) * 16, ModLoader.GetMod("Antiaris").NPCType("Mirror"), 0, 0f, 0f, 0f, 0f, 255);
			Main.npc[SpawnMirror].homeTileX = -1;
			Main.npc[SpawnMirror].homeTileY = -1;
			Main.npc[SpawnMirror].direction = 1;
			Main.npc[SpawnMirror].homeless = false;
			TowerPositionY += 2;
			for (var x = 0; x < TowerTiles.GetLength(1); x++)
            {
                for (var y = 0; y < TowerTiles.GetLength(0); y++)
                {
                    var tile = Framing.GetTileSafely(TowerPositionX + x, TowerPositionY - y);
                    switch (TowerTiles[y, x])
                    {
                        case 0:
                            WorldGen.KillTile(TowerPositionX + x, TowerPositionY - y, false, false, true);
                            break;
                        case 1:
                            tile.type = TileID.Dirt;
                            tile.active(true);
                            break;
                        case 2:
                            tile.type = 38;
                            tile.active(true);
                            break;
						case 3:
						    tile.type = (ushort)(!WorldGen.crimson ? 140 : 347);
                            tile.active(true);
							break;
						case 4:
                            WorldGen.PlaceTile(TowerPositionX + x, TowerPositionY - y, TileID.Platforms, true, true, -1, (ushort)(!WorldGen.crimson ? 1 : 5));
							break;
                    }
					if (TowerSlopes[y, x] == 5)
                    {
                        tile.halfBrick(true);
                    }
                    else
                    {
                        tile.halfBrick(false);
                        tile.slope(TowerSlopes[y, x]);
                    }
				    switch (TowerWalls[y, x])
                    {
                        case 0:
                            tile.wall = 0;
                            break;
                        case 1:
                            tile.wall = 5;
                            break;
                        case 2:
                            tile.wall = (ushort)(!WorldGen.crimson ? 33 : 174);
                            break;
                    }
					WorldGen.PlaceObject(TowerPositionX + 2, TowerPositionY - 3, 10, true, (ushort)(!WorldGen.crimson ? 1 : 10));
					WorldGen.PlaceObject(TowerPositionX + 12, TowerPositionY - 3, 10, true, (ushort)(!WorldGen.crimson ? 1 : 10));
					WorldGen.PlaceObject(TowerPositionX + 7, TowerPositionY - 3, 101, true, (ushort)(!WorldGen.crimson ? 7 : 19));
					WorldGen.PlaceObject(TowerPositionX + 6, TowerPositionY - 10, 79, true, (ushort)(!WorldGen.crimson ? 1 : 4), -1, 1);
					WorldGen.PlaceChest(TowerPositionX + 9, TowerPositionY - 18, 21, false, (ushort)(!WorldGen.crimson ? 7 : 14));
                    var TowerChestIndex = Chest.FindChest(TowerPositionX + 9, TowerPositionY - 19);
                    if (TowerChestIndex != -1)
                    {
                        do_TowerChestLoot(Main.chest[TowerChestIndex].item);
                    }
                }
            }
			if (progress == null)
            {
                for (var x = TowerPositionX; x <= TowerPositionX + 15; x++)
                {
                    for (var y = TowerPositionY - 28; y <= TowerPositionY; y++)
                    {
                        WorldGen.SquareTileFrame(x, y);
                        WorldGen.SquareWallFrame(x, y);
                    }
                }
            }
			return true;
		}

        bool do_MakeChestFinder(GenerationProgress progress)
        {
            goto Success;
            AntiarisHelper.Log("Continue...");
            return false;

            Success:
            int chestIndex;
            int inventoryIndex;
            int[] itemsToPlaceInIceChests = new int[] { ModLoader.GetMod("Antiaris").ItemType("ChestFinder") };
            int itemsToPlaceInIceChestsChoice = 0;
			int[] itemsToPlaceInIceChests2 = new int[] { ModLoader.GetMod("Antiaris").ItemType("UndyingArmyRifle") };
            int itemsToPlaceInIceChestsChoice2 = 0;
            for (chestIndex = 0; chestIndex < 1000; chestIndex++)
            {
                var chest = Main.chest[chestIndex];
                if (chest != null && Main.tile[chest.x, chest.y].frameX == 0 * 36 && Main.rand.Next(25) <= 1)
                {
                    for (inventoryIndex = 0; inventoryIndex < 40; inventoryIndex++)
                    {
                        itemsToPlaceInIceChestsChoice = Main.rand.Next(itemsToPlaceInIceChests.Length);
                        chest.item[0].SetDefaults(itemsToPlaceInIceChests[itemsToPlaceInIceChestsChoice]);
                        break;
                    }
                }
				if (chest != null && Main.tile[chest.x, chest.y].frameX == 2 * 36 && Main.rand.Next(20) <= 1)
                {
                    for (inventoryIndex = 0; inventoryIndex < 40; inventoryIndex++)
                    {
                        itemsToPlaceInIceChestsChoice2 = Main.rand.Next(itemsToPlaceInIceChests2.Length);
                        chest.item[0].SetDefaults(itemsToPlaceInIceChests2[itemsToPlaceInIceChestsChoice2]);
                        break;
                    }
                }
            }
            //thanks graydee
            //GenerateCrystal:
            var X = 1;
            var Y = 1;
            var widthScale = (Main.maxTilesX / 4200f);
            var numberToGenerate = 35;
            for (var k = 0; k < (int)(numberToGenerate * widthScale); k++)
            {
                var placement = false;
                var placed = false;
                while (!placed)
                {
                    var success = false;
                    var attempts = 0;
                    while (!success)
                    {
                        attempts++;
                        if (attempts > 1000)
                        {
                            success = true;
                            continue;
                        }
                        var i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
                        var j = WorldGen.genRand.Next((int)((double)Main.maxTilesY * 0.349999994039536), Main.maxTilesY - 50);
                        if (i <= Main.maxTilesX / 2 - 50 || i >= Main.maxTilesX / 2 + 50)
                        {
                            if (Main.tile[i, j].type == 57)
                            {
                                placement = AntiarisHelper.Placement(i, j);
                                if (placement)
                                {
                                    X = i;
                                    Y = j;
                                    for (var I = 0; I < 250; I++)
                                    {
                                        var why = Main.rand.Next(-15, 15);
                                        var ex = Main.rand.Next(-40, 40);
                                        WorldGen.PlaceObject(i + ex, j + why, ModLoader.GetMod("Antiaris").TileType("BlazingHeart"));
                                    }
                                    success = true;
                                    placed = true;
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        void do_SnowHouseLoot(Item[] ChestInventory)
        {
            var item = 0;
            var mod = ModLoader.GetMod("Antiaris");
            switch (Main.rand.Next(0, 3))
            {
                case 0:
                    item = mod.ItemType("SteelBow");
                    break;
                case 1:
                    item = mod.ItemType("SteelKnife");
                    break;
                default:
                    item = mod.ItemType("LeatherGlove");
                    break;
            }
            ChestInventory[0].SetDefaults(item);
            ChestInventory[1].SetDefaults(mod.ItemType("RobberSack"));
            ChestInventory[1].stack = Main.rand.Next(3, 6);
            ChestInventory[2].SetDefaults(ItemID.Torch);
            ChestInventory[2].stack = Main.rand.Next(10, 20);
            ChestInventory[3].SetDefaults(ItemID.ThrowingKnife);
            ChestInventory[3].stack = Main.rand.Next(25, 50);
            ChestInventory[4].SetDefaults(ItemID.HealingPotion);
            ChestInventory[4].stack = Main.rand.Next(2, 5);
            ChestInventory[5].SetDefaults(ItemID.GoldCoin);
            ChestInventory[5].stack = Main.rand.Next(3, 5);
        }

        void do_GuideHouseLoot(Item[] ChestInventory)
        {
            ChestInventory[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("LeafRoll"));
            ChestInventory[1].SetDefaults(ItemID.Rope);
            ChestInventory[1].stack = Main.rand.Next(40, 80);
            ChestInventory[2].SetDefaults(ItemID.Grenade);
            ChestInventory[2].stack = Main.rand.Next(8, 12);
            ChestInventory[3].SetDefaults(ItemID.Book);
            ChestInventory[3].stack = Main.rand.Next(3, 6);
            ChestInventory[4].SetDefaults(ItemID.IronBar);
            ChestInventory[4].stack = Main.rand.Next(3, 6);
            ChestInventory[5].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("PruningShears"));
        }

        void do_GuideHouseLoot2(Item[] ChestInventory)
		{
			ChestInventory[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("Note")); 
		}

        void do_PirateBoatLoot(Item[] ChestInventory)
        {
            ChestInventory[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("TreasureAmulet")); 
            ChestInventory[1].SetDefaults(ItemID.GoldCoin);
            ChestInventory[1].stack = Main.rand.Next(10, 14);
            ChestInventory[2].SetDefaults(ItemID.HealingPotion);
            ChestInventory[2].stack = Main.rand.Next(9, 15);
            ChestInventory[3].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("Note2"));
        }

        void do_PyramidLoot(Item[] ChestInventory)
        {
            ChestInventory[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("SandstormBoots"));
            ChestInventory[1].SetDefaults(ItemID.GoldCoin);
            ChestInventory[1].stack = Main.rand.Next(8, 12);
            ChestInventory[2].SetDefaults(ItemID.HealingPotion);
            ChestInventory[2].stack = Main.rand.Next(10, 12);
            ChestInventory[3].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("EnchantedShard"));
            ChestInventory[3].stack = Main.rand.Next(7, 11);
        }

        void do_SunkenSubmarineLoot(Chest chest)
        {
            chest.item[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("ScubaGear"));
            var i = 1;
            if (WorldGen.genRand.NextBool(1, 3))
            {
                chest.item[i].SetDefaults(ItemID.Bomb);
                chest.item[i].stack = WorldGen.genRand.Next(10, 20);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 5))
            {
                chest.item[i].SetDefaults(ItemID.AngelStatue);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 3))
            {
                chest.item[i].SetDefaults(ItemID.Rope);
                chest.item[i].stack = WorldGen.genRand.Next(50, 100);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 2))
            {
                chest.item[i].SetDefaults(WorldGen.genRand.NextBool() ? WorldGen.ironBar : WorldGen.silverBar);
                chest.item[i].stack = WorldGen.genRand.Next(5, 15);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 2))
            {
                chest.item[i].SetDefaults(WorldGen.genRand.NextBool() ? ItemID.WoodenArrow : ItemID.Shuriken);
                chest.item[i].stack = WorldGen.genRand.Next(50, 100);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 2))
            {
                chest.item[i].SetDefaults(ItemID.LesserHealingPotion);
                chest.item[i].stack = WorldGen.genRand.Next(3, 6);
                i++;
            }
            if (WorldGen.genRand.NextBool(2, 3))
            {
                int type = 0;
                switch (Main.rand.Next(8))
                {
                    case 0:
                        type = ItemID.RegenerationPotion;
                        break;
                    case 1:
                        type = ItemID.ShinePotion;
                        break;
                    case 2:
                        type = ItemID.NightOwlPotion;
                        break;
                    case 3:
                        type = ItemID.SwiftnessPotion;
                        break;
                    case 4:
                        type = ItemID.ArcheryPotion;
                        break;
                    case 5:
                    case 6:
                        type = ItemID.GillsPotion;
                        break;
                    case 7:
                        type = ItemID.HunterPotion;
                        break;
                }
                chest.item[i].SetDefaults(type);
                chest.item[i].stack = WorldGen.genRand.Next(1, 5);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 2))
            {
                chest.item[i].SetDefaults(ItemID.Glowstick);
                chest.item[i].stack = WorldGen.genRand.Next(10, 20);
                i++;
            }
            if (WorldGen.genRand.NextBool(2, 3))
            {
                chest.item[i].SetDefaults(ItemID.RecallPotion);
                i++;
            }
            if (WorldGen.genRand.NextBool(1, 4))
            {
                chest.item[i].SetDefaults(ItemID.SilverCoin);
                chest.item[i].stack = WorldGen.genRand.Next(50, 90);
                i++;
            }
            else if (WorldGen.genRand.NextBool(1, 4))
            {
                chest.item[i].SetDefaults(ItemID.GoldCoin);
                i++;
            }
        }

        void do_TowerChestLoot(Item[] ChestInventory)
        {
            ChestInventory[0].SetDefaults(!WorldGen.crimson ? ItemID.DemoniteBar : ItemID.CrimtaneBar); 
            ChestInventory[0].stack = Main.rand.Next(5, 7);
            ChestInventory[1].SetDefaults(ItemID.GoldCoin);
            ChestInventory[1].stack = Main.rand.Next(3, 4);
            ChestInventory[2].SetDefaults(ItemID.LesserHealingPotion);
            ChestInventory[2].stack = Main.rand.Next(6, 10);
            ChestInventory[3].SetDefaults(ItemID.RecallPotion);
            ChestInventory[3].stack = Main.rand.Next(2, 4);
            ChestInventory[4].SetDefaults(ItemID.Rope);
            ChestInventory[4].stack = Main.rand.Next(30, 40);
        }

        public static void do_PirateCoveLoot(Item[] ChestInventory)
        {
			var mod = ModLoader.GetMod("Antiaris");
			var item = 0;
			switch (Main.rand.Next(0, 5))
            {
                case 0:
                    item = mod.ItemType("GildedCannon");
                    break;
				case 1:
                    item = mod.ItemType("TheBuccaneersBuster");
                    break;
				case 2:
                    item = mod.ItemType("CrossboneStaff");
                    break;
				case 3:
                    item = mod.ItemType("DavyJonessPendant");
                    break;
                default:
                    item = mod.ItemType("TheJollyRoger");
                    break;
            }
			ChestInventory[0].SetDefaults(item);
            var item1 = 0;
            switch (Main.rand.Next(0, 2))
            {
                case 0:
                    item1 = mod.ItemType("GiantEmerald");
                    break;
                default:
                    item1 = mod.ItemType("GiantDiamond");
                    break;
            }
            ChestInventory[1].SetDefaults(item1);
			var item2 = 0;
			switch (Main.rand.Next(0, 3))
            {
                case 0:
                    item2 = ItemID.MechanicalSkull;
                    break;
				case 1:
					item2 = ItemID.MechanicalEye;
					break;
                default:
                    item2 = ItemID.MechanicalWorm;
                    break;
            }
			ChestInventory[2].SetDefaults(item2);
			var item3 = 0;
			switch (Main.rand.Next(0, 13))
            {
                case 0:
                    item3 = ItemID.ArcheryPotion;
                    break;
				case 1:
					item3 = ItemID.TrapsightPotion;
					break;
				case 2:
					item3 = ItemID.FlipperPotion;
					break;
				case 3:
					item3 = ItemID.GravitationPotion;
					break;
				case 4:
					item3 = ItemID.HeartreachPotion;
					break;
				case 5:
					item3 = ItemID.HunterPotion;
					break;
				case 6:
					item3 = ItemID.InvisibilityPotion;
					break;
				case 7:
					item3 = ItemID.MiningPotion;
					break;
				case 8:
					item3 = ItemID.NightOwlPotion;
					break;
				case 9:
					item3 = ItemID.RecallPotion;
					break;
				case 10:
					item3 = ItemID.SpelunkerPotion;
					break;
				case 11:
					item3 = ItemID.ThornsPotion;
					break;
				case 12:
					item3 = ItemID.WaterWalkingPotion;
					break;
                default:
                    item3 = ItemID.FeatherfallPotion;
                    break;
            }
			ChestInventory[3].SetDefaults(item3);
			ChestInventory[3].stack = Main.rand.Next(2, 4);
            var item4 = 0;
            switch(Main.rand.Next(0, 5))
            {
                case 0:
                    item4 = ItemID.CobaltBar;
                    break;
                case 1:
                    item4 = ItemID.PalladiumBar;
                    break;
                case 2:
                    item4 = ItemID.MythrilBar;
                    break;
                case 3:
                    item4 = ItemID.OrichalcumBar;
                    break;
                case 4:
                    item4 = ItemID.AdamantiteBar;
                    break;
                default:
                    item4 = ItemID.TitaniumBar;
                    break;
            }
            ChestInventory[4].SetDefaults(item4);
            ChestInventory[4].stack = Main.rand.Next(15, 25);
        }

        public static void do_HiveShrineLoot(Item[] ChestInventory)
        {
            ChestInventory[0].SetDefaults((ushort)ModLoader.GetMod("Antiaris").ItemType("BeePheromones"));
            ChestInventory[1].SetDefaults(ItemID.BottledHoney);
            ChestInventory[1].stack = Main.rand.Next(3, 5);
            ChestInventory[2].SetDefaults(ItemID.Beenade);
            ChestInventory[2].stack = Main.rand.Next(10, 20);
            ChestInventory[3].SetDefaults(ItemID.GoldCoin);
            ChestInventory[3].stack = Main.rand.Next(1, 4);
        }

        public override void PostWorldGen()
        {
            if (!Main.dedServ && !Main.gameMenu)
            { 
                WorldGen.EveryTileFrame();
                Player player = Main.player[Main.myPlayer];
                Main.blockInput = false;
                Main.blockMouse = false;
                Main.hideUI = false;
                heavenTimer = 0;
                heavenClock = 0;
                player.GetModPlayer<AntiarisPlayer>().darkness = 0;
                Main.musicVolume = player.GetModPlayer<AntiarisPlayer>().musicVolume;
                Main.soundVolume = player.GetModPlayer<AntiarisPlayer>().soundVolume;
                Main.ambientVolume = player.GetModPlayer<AntiarisPlayer>().ambientVolume;
                for (int i = 0; i < Main.item.Length; i++)
                {
                    Main.item[i].active = false;
                }
                for (int i = 0; i < Main.npc.Length; i++)
                {
                    if (!Main.npc[i].friendly)
                        Main.npc[i].active = false;
                }
            }
        }
    }
}

